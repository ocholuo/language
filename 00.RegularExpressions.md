# 正则表达式

[toc]

## intro

www.regexr.com


ref
https://www.runoob.com/regexp/regexp-example.html
https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expressions
https://www.regular-expressions.info/



![Screen Shot 2020-04-12 at 22.28.15](https://i.imgur.com/FtEA7MZ.png)


Regular expressions provide a powerful, flexible, and efficient method for processing text. The extensive `pattern-matching notation` of regular expressions enables you
- to `quickly parse` 从语法上描述或分析 large amounts of text to find specific character patterns;
- to `validate text` to ensure that it matches a predefined pattern (such as an email address);
- to `extract, edit, replace, or delete` text substrings;
- to add the extracted strings to a collection in order to generate a report.

For many applications that deal with strings or that parse large blocks of text, regular expressions are an indispensable tool.

正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（"元字符"）。
- 正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。
- 是繁琐的，但它是强大的，许多程序设计语言都支持利用正则表达式进行字符串操作。

```xml
//以下实例从字符串 str 中找出数字：
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    <title>菜鸟教程(runoob.com)</title>
  </head>

<body>

<script>
var str = "abc123def";
var patt1 = /[0-9]+/;
document.write(str.match(patt1));
</script>

</body>
</html>

获得的匹配的表达式：
123
```

---

### How Regular Expressions Work
The centerpiece of text processing with regular expressions is the `regular expression engine`, which is represented by the `System.Text.RegularExpressions.Regex` object in `.NET`.

- At a minimum, processing text using regular expressions requires that the `regular expression engine` be provided with the following two items of information:
  - The `regular expression pattern` to identify in the text.
    - In `.NET`, `regular expression patterns` are defined by a special syntax or language, which is compatible with Perl 5 regular expressions and adds some additional features such as right-to-left matching.
      - *Regular Expression Language - Quick Reference*
  - The text to parse for the regular expression pattern.

The methods of the `Regex class` let you perform the following operations:

  - Determine whether the regular expression pattern occurs in the input text by calling the **Regex.IsMatch** method. For an example that uses the `IsMatch` method for validating text,
    - see *How to: Verify that Strings Are in Valid Email Format*.

  - Retrieve one or all occurrences of text that matches the regular expression pattern by calling the **Regex.Match** or **Regex.Matches** method.
    - `Regex.Match` method returns a `System.Text.RegularExpressions.Match` object that provides information about the matching text.
    - `Regex.Matches` method returns a `MatchCollection` object that contains one `System.Text.RegularExpressions.Match` object for each match found in the parsed text.

  - Replace text that matches the regular expression pattern by calling the **Regex.Replace** method. For examples that use the Replace method to change date formats and remove invalid characters from a string,
    - see *How to: Strip Invalid Characters from a String and Example: Changing Date Formats*.

---

### Text Patterns and Matches

A regular expression is a pattern *describing a certain amount of text*.

- On this website, `regular expressions` <font color=red> regex </font> are highlighted in red

- pattern simply matching the literal text regex. `Matches` <font color=blue> regex </font> are highlighted in blue on this site.
  - A `match` is the piece of text, or sequence of bytes or characters that pattern was found to correspond to by the regex processing software.

- `string`: the text that the regular expression is applied to. <font color=green> Strings </font> are highlighted in green.


Characters with special meanings in regular expressions are highlighted in various different colors.
- The regex: `(?x)([Rr]egexp?)\?`
- meta tokens: (?x)
- grouping: ()
- character classes: [Rr]
- quantifiers and other special tokens: ?
- escaped characters: `\?`

---

### Different Regular Expression Engines
A `regular expression engine` is a piece of software that can process regular expressions, trying to match the pattern to the given string.
- Usually, the engine is part of a larger application and you do not access the engine directly. Rather, the application invokes it for you when needed, making sure the right regular expression is applied to the right file or data.

- As usual in the software world, different regular expression engines are not fully compatible with each other. The syntax and behavior of a particular engine is called a `regular expression flavor`.
- the popular regular expression flavors, including `Perl, PCRE, PHP, .NET, Java, JavaScript, XRegExp, VBScript, Python, Ruby, Delphi, R, Tcl, POSIX,` and many others.


### How a Regex Engine Works Internally
While there are many implementations of regular expressions that differ sometimes slightly and sometimes significantly in syntax and behavior, there are basically only two kinds of regular expression engines: `text-directed engines`, and `regex-directed engines`. N
early all modern regex flavors are based on regex-directed engines. because certain very useful features, such as lazy quantifiers and backreferences, can only be implemented in regex-directed engines.

A `regex-directed engine` walks through the `regex`, attempting to match the next token in the regex to the next character. If a match is found, the engine advances through the regex and the subject string. If a token fails to match, the engine backtracks to a previous position in the regex and the subject string where it can try a different path through the regex. This tutorial will talk a lot more about backtracking later on. Modern regex flavors using regex-directed engines have lots of features such as atomic grouping and possessive quantifiers that allow you to control this backtracking.

A `text-directed engine` walks through the `subject string`, attempting all permutations of the regex before advancing to the next character in the string. A text-directed engine never backtracks. Thus, there isn’t much to discuss about the matching process of a text-directed engine. In most cases, a text-directed engine finds the same matches as a regex-directed engine.

When this tutorial talks about regex engine internals, the discussion assumes a regex-directed engine. It only mentions text-directed engines in situations where they find different matches. And that only really happens when your regex uses alternation with two alternatives that can match at the same position.

### The Regex Engine Always Returns the Leftmost Match
This is a very important point to understand: a regex engine always returns the leftmost match, even if a “better” match could be found later.

When applying a regex to a string, the engine starts at the `first character` of the string.
- It tries all possible permutations of the regular expression at the first character.
- Only if all possibilities have been tried and found to fail, does the engine continue with the second character in the text.
- it tries all possible permutations of the regex, in the same order. the regex engine returns the leftmost match.

When applying `cat` to `"He captured a catfish for his cat."`
- the engine match the first `token` in the regex c to the first character in the match H. This fails. There are no other possible permutations of this regex, because it merely consists of a sequence of literal characters.
- So the regex engine tries to match the c with the e. This fails too
- Arriving at the 4th character in the string, c matches c. The engine then tries to match the second `token` a to the 5th character, a. This succeeds too.
- But then, t fails to match p. At that point, the engine knows `the regex cannot be matched starting at the 4th character` in the string.
- So it continues with the 5th: a. Again, c fails to match here and the engine carries on.
- At the 15th character in the string, c again matches c. The engine then proceeds to attempt to match the remainder of the regex at character 15 and finds that a matches a and t matches t.
- The entire regular expression could be matched starting at character 15. The engine is “eager” to report a match. It therefore reports the `first three letters of catfish` as a valid match.

The engine never proceeds beyond this point to see if there are any “better” matches. The first match is considered good enough.


---

## 正则表达式 - 简介

不涉及脚本的某些正则表达式概念。
- 使用 ? 和 * 通配符来查找硬盘上的文件。?
- `?` 通配符匹配文件名中的 0 个或 1 个字符，
- `*` 通配符匹配零个或多个字符。

像 `data(\w)?\.dat` 这样的模式将查找下列文件：

    data.dat
    data1.dat
    data2.dat
    datax.dat
    dataN.dat

使用 * 字符代替 ? 字符扩大了找到的文件的数量。
- `data.*\.dat` 匹配下列所有文件：

      data.dat
      data1.dat
      data2.dat
      data12.dat
      datax.dat
      dataXYZ.dat

尽管这种搜索方法很有用，但它还是有限的。

正则表达式功能更强大，而且更加灵活。

正则表达式的使用，可以通过简单的办法来实现强大的功能。


```py
# 示例
^[0-9]+abc$

- ^ 为匹配输入字符串的开始位置。
- [0-9]+ 匹配多个数字
  - [0-9] 匹配单个数字，
  - + 匹配一个或者多个。
- abc$ 匹配字母 abc 并以 abc 结尾，$ 为匹配输入字符串的结束位置。


# 写用户注册表单时，只允许用户名包含字符、数字、下划线和连接字符(-)，并设置用户名的长度，就可以使用以下正则表达式来设定。
^[a-z0-9_-]{3,15}$

- ^  开始标记。
- [a-z0-9_-] 匹配多个数字a-z_-
- {3,15} 3to15 long
- $ 结束标记。

以上的正则表达式可以匹配 runoob、runoob1、run-oob、run_oob，
但不匹配 ru，因为它包含的字母太短了，小于 3 个无法匹配。
也不匹配 runoob$, 因为它包含特殊字符$。



# 匹配以数字开头，并以 abc 结尾的字符串。
var str = "123abc";
var patt1 = /^[0-9]+abc$/;
document.write(str.match(patt1));
# 以下标记的文本是获得的匹配的表达式：
123abc
```

### 为什么使用正则表达式？
典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。

通过使用正则表达式，可以：
- 测试字符串内的模式。
  - 例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为`数据验证`。
- 替换文本。
  - 可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。
- 基于模式匹配从字符串中提取子字符串。
  - 可以查找文档内或输入域内特定的文本。


例如，您可能需要搜索整个网站，删除过时的材料，以及替换某些 HTML 格式标记。在这种情况下，可以使用正则表达式来确定在每个文件中是否出现该材料或该 HTML 格式标记。此过程将受影响的文件列表缩小到包含需要删除或更改的材料的那些文件。然后可以使用正则表达式来删除过时的材料。最后，可以使用正则表达式来搜索和替换标记。

---

## 正则表达式 - 语法
正则表达式(regular expression)描述了一种字符串匹配的模式（pattern）
- 可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。

例如：

runo`o+`b，可以匹配 runoob、runooob、runoooooob 等，
- `+` 号代表前面的字符必须`至少出现一次`（1次或多次）。

runo`o*`b，可以匹配 runob、runoob、runoooooob 等，
- `*` 号代表字符`可以不出现，也可以出现一次或者多次`（0次、或1次、或多次）。

colo`u?`r 可以匹配 color 或者 colour，
- `?` 问号代表前面的字符`最多只可以出现一次`（0次、或1次）。


构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。

正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为"元字符"）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。


### Character Classes or Character Sets `[]`
With a “character class/set”, you can tell the regex engine to match only one out of several characters. Simply place the characters you want to match between square brackets.
- The *order of the characters* inside a character class does not matter.The results are identical.

to match an a or an e, use `[ae]`.
- use `gr[ae]y` to match either gray or grey.
- Very useful if you do not know whether the document you are searching through is written in American or British English.

A `character class` matches only a single character.
- `gr[ae]y` does not match graay, graey or any such thing.


`a range of characters`: use a `hyphen` inside a character class
- `[0-9]` matches a single digit between 0 and 9.

use more than one range.
- `[0-9a-fA-F]` matches a single hexadecimal digit, case insensitively.

combine ranges and single characters.
- `[0-9a-fxA-FX]` matches a hexadecimal digit or the letter X.
- the order of the characters and the ranges does not matter.


Character classes are one of the most commonly used features of regular expressions.

- find a word, even if it is misspelled such as `sep[ae]r[ae]te` or `li[cs]en[cs]e`.

- find an identifier in a programming language with `[A-Za-z_][A-Za-z_0-9]*`.

- find a C-style hexadecimal number with `0[xX][A-Fa-f0-9]+`.


### Negated Character Classes [`^`abc]
Typing a `caret` after the `opening square bracket` negates the character class.
- The result: the character class matches any character that is not in the character class.

Unlike the dot, negated character classes also match (invisible) line break characters. If you don’t want a negated character class to match line breaks, you need to include the line break characters in the class.
- `[^0-9\r\n]` matches any character that is not a digit or a line break.

It is important to remember that a `negated character class` still *must match a character*.
- `q[^u]`
- does not mean: “a q not followed by a u”.
- It means: “a q followed by a character that is not a u”.
- It does not match the q in the string `Iraq`.
- It does match the q and the space after the q in `Iraq is a country`.

Indeed: the space becomes part of the overall match, because it is the “character that is not a u” that is matched by the negated character class in the above regexp. If you want the regex to match the q, and only the q, in both strings, you need to use negative lookahead: `q(?!u)`. But we will get to that later.

### Metacharacters Inside Character Classes
In most regex flavors, the only `special characters` or `metacharacters` inside a `character class` are the closing bracket `]`, the backslash `\`, the caret `^`, and the hyphen `-`.

The usual `metacharacters` are normal characters inside a `character class`, and do not need to be escaped by a `backslash`.
- To search for a star or plus, use `[+*]`.
- Your regex will work fine if you escape the regular metacharacters inside a character class, but doing so significantly reduces readability.

To include a backslash as a character without any special meaning inside a character class, you have to escape it with another backslash.
- `[\\x]` matches a backslash or an x.
- The closing bracket ], the caret ^ and the hyphen - can be included by escaping them with a backslash, or by placing them in a position where they do not take on their special meaning. The POSIX and GNU flavors are an exception. They treat backslashes in character classes as literal characters. So with these flavors, you can’t escape anything in character classes.

To include an unescaped caret as a literal, place it anywhere except right after the opening bracket.
- `[x^]` matches an x or a caret. This works with all flavors discussed in this tutorial.

You can include an unescaped closing bracket by placing it right after the opening bracket, or right after the negating caret.
- `[]x]` matches a closing bracket or an x.
- `[^]x]` matches any character that is `not a closing bracket or an x`. This does not work in JavaScript, which treats [] as an empty character class that always fails to match, and [^] as a negated empty character class that matches any single character. Ruby treats empty character classes as an error. So both JavaScript and Ruby require closing brackets to be escaped with a backslash to include them as literals in a character class.

The hyphen can be included right after the opening bracket, or right before the closing bracket, or right after the negating caret.
- Both [-x] and [x-] match an x or a hyphen.
- [^-x] and [^x-] match any character that is not an x or a hyphen.
- This works in all flavors discussed in this tutorial. Hyphens at other positions in character classes where they can’t form a range may be interpreted as literals or as errors. Regex flavors are quite inconsistent about this.

Many regex tokens that work outside character classes can also be used inside character classes. This includes character escapes, octal escapes, and hexadecimal escapes for non-printable characters. For flavors that support Unicode, it also includes Unicode character escapes and Unicode properties. `[$\u20AC]` matches a dollar or euro sign, assuming your regex flavor supports Unicode escapes.

### Repeating Character Classes
If you repeat a character class by using the ?, * or + operators, you’re repeating the entire character class. You’re not repeating just the character that it matched.
- `[0-9]+` can match 837 as well as 222.

If you want to repeat the matched character, rather than the class, you need to use backreferences.
- `([0-9])\1+` matches 222 but not 837. When applied to the string 833337, it matches 3333 in the middle of this string. If you do not want that, you need to use lookaround.

### Looking Inside The Regex Engine
As was mentioned earlier: the order of the characters inside a character class does not matter.
- `gr[ae]y` matches `grey` in `"Is his hair grey or gray?"`, because that is the leftmost match.

We already saw how the engine applies a regex consisting only of literal characters. Now we’ll see *how it applies a regex that has more than one permutation*.
- `gr[ae]y` can match both gray and grey.
- Nothing noteworthy happens for the first twelve characters in the string. The engine fails to match `g` at every step, and continues with the next character in the string.
- When the engine arrives at the 13th character, `g` is matched. The engine then tries to match the remainder of the regex with the text. The next token in the regex is the literal `r`, which matches the next character in the text. So the third token, `[ae]` is attempted at the next character in the text (e).
- The character class gives the engine two options: match `a` or match `e`.
- It first attempts to match `a`, and fails.

But because we are using a `regex-directed` engine, it must continue trying to match all the other `permutations of the regex pattern` before deciding that the regex cannot be matched with the text starting at character 13.
- So it continues with the other option, and finds that `e` matches `e`. The last regex token is `y`, which can be matched with the following character as well. The engine has found a `complete match` with the text starting at character 13.
- It returns `grey` as the match result, and looks no further. Again, the `leftmost match` is returned, even though we put the `a` first in the character class, and `gray` could have been matched in the string.
- But the engine simply did not get that far, because another equally valid match was found to the left of it.
- `gray` is only matched if you tell the regex engine to continue looking for a second match in the remainder of the subject string after the first match.

---

### Character Class `Subtraction` 减法 `[class-[subtract]]`.
`Character class subtraction` is supported by the XML Schema, XPath, .NET (version 2.0 and later), and JGsoft regex flavors.
- It makes it easy to match `any single character` present in `one list (the character class)`, but not present in `another list (the subtracted class)`.
- syntax: `[class-[subtract]]`.
- If the character after a hyphen is an `opening bracket`, these flavors interpret the `hyphen` as the `subtraction operator` rather than the `range operator`. You can use the full character class syntax within the subtracted character class.

- The character class `[a-z-[aeiuo]]`: single letter that is not a vowel. it matches a single consonant.
  - Without `character class subtraction / intersection`, the only way to do this would be to list all consonants: `[b-df-hj-np-tv-z]`.

- The character class `[\p{Nd}-[^\p{IsThai}]]` matches any single Thai digit. The base class matches any Unicode digit. All non-Thai characters are subtracted from that class.
  - `[\p{Nd}-[\P{IsThai}]]` does the same.
  - `[\p{IsThai}-[^\p{Nd}]]` and `[\p{IsThai}-[\P{Nd}]]` also match a single Thai digit by subtracting all non-digits from the Thai characters.

#### Nested Character Class Subtraction
1. Since you can use the `full character class` syntax within the `subtracted character class`, you can `subtract a class from the class being subtracted`.

    - `[0-9-[0-6-[0-3]]]`
      - first subtracts 0-3 from 0-6,
      - yielding `[0-9-[4-6]]`, or `[0-37-9]`, which matches any character in the string 0123789.

2. The `class subtraction` must always be the last element in the character class.

    - `[0-9-[4-6]a-f]`: not a valid regular expression.
      - It should be rewritten as `[0-9a-f-[4-6]]`.

3. The subtraction works on the whole class.

    - `[\p{Ll}\p{Lu}-[\p{IsBasicLatin}]]` matches all uppercase and lowercase Unicode letters, except any ASCII letters.
    - The `\p{IsBasicLatin}` is subtracted from the combination of `\p{Ll}\p{Lu}` rather than from `\p{Lu}` alone.
    - This regex will not match `abc`.

4. While you can use nested character class subtraction, you cannot subtract two classes sequentially.

    - To subtract `ASCII characters` and `Greek characters` from a class with all `Unicode letters`, combine the ASCII and Greek characters into one class, and subtract that, as in `[\p{L}-[\p{IsBasicLatin}\p{IsGreek}]]`.

#### Negation `^` Takes Precedence over Subtraction `[-]`
The character class `[^1234-[3456]]` is both `negated and subtracted from`.
- In all flavors that support character class subtraction, the `base class` is negated before it is subtracted from.
- This class should be read as `“(not 1234) minus 3456”`.
- Thus this character class matches any character other than the digits` 1, 2, 3, 4, 5, and 6`.

#### Notational Compatibility with Other Regex Flavors
regex like `[a-z-[aeiuo]]` does not cause any errors in most regex flavors that do not support character class subtraction.

- But it won’t match what you intended either.

In most flavors, this regex consists of a character class followed by a literal `]`.
- The character class matches a character that is either in the range `a-z, or a hyphen, or an opening bracket, or a vowel`.
- Since the a-z range and the vowels are redundant, you could write this character class as `[a-z-[]` or `[-[a-z]` in Perl.
- A hyphen after a range `[abc]-` is treated as a literal character, just like a hyphen immediately after the opening bracket. This is true in the XML, .NET and JGsoft flavors too.
  - `[a-z-_]` matches a lowercase letter, a hyphen or an underscore in these flavors.

Strictly speaking, this means that the `character class subtraction` syntax is incompatible with Perl and the majority of other regex flavors.

But in practice there’s no difference.

Using non-alphanumeric characters in character class ranges is very bad practice because it relies on the order of characters in the ASCII character table. That makes the regular expression hard to understand for the programmer who inherits your work.

While `[A-[]` would match any uppercase letter or an opening square bracket in Perl, this regex is much clearer when written as [A-Z[].
- The former regex would cause an error with the XML, .NET and JGsoft flavors, because they interpret `-[]` as an empty `subtracted class`, leaving an unbalanced `[`.

---

### Character Class `Intersection` `ampersands` `[class&&[intersect]]`
makes it easy to match `any single character that must be present in two sets of characters`.

- syntax: `[class&&[intersect]]`.

  - Character class intersection is supported by Java, JGsoft V2, and by Ruby 1.9 and later.

  - If the intersected class does not need a negating caret `^` , then Java and Ruby allow you to omit the nested square brackets: `[class&&intersect]`.

  - You cannot omit the nested square brackets in PowerGREP. If you do, PowerGREP interprets the ampersands as literals. So in PowerGREP `[class&&intersect]` is a character class containing only literals, just like `[clas&inter]`.

- The character class `[a-z&&[^aeiuo]]` matches a single letter that is not a vowel. In other words: it matches a single consonant. Without character class subtraction or intersection, the only way to do this would be to list all consonants: `[b-df-hj-np-tv-z]`.

- The character class `[\p{Nd}&&[\p{IsThai}]]` matches any single Thai digit. `[\p{IsThai}&&[\p{Nd}]]` does exactly the same.

#### Intersection of Multiple Classes
You can intersect the same class more than once.

- `[0-9&&[0-6&&[4-9]]]` is the same as `[4-6]` as those are the only digits present in all three parts of the intersection.

- In Java and Ruby you can write the same regex as `[0-9&&[0-6]&&[4-9]]`, `[0-9&&[0-6&&4-9]]`, `[0-9&&0-6&&[4-9]]`, or just `[0-9&&0-6&&4-9]`. The nested square brackets are only needed if one of the parts of the intersection is negated.

- If you do not use square brackets around the right hand part of the intersection, then there is no confusion that the entire remainder of the character class is the right hand part of the intersection.

- If you do use the square brackets, you could write something like `[0-9&&[12]56]`.
  - In Ruby, this is the same as `[0-9&&1256]`.
  - But Java has bugs that cause it to treat this as `[0-9&&56]`, completely ignoring the nested brackets.
  - PowerGREP does not allow anything after the nested `]`. The characters `56` in `[0-9&&[12]56]` are an error. This way there is no ambiguity about their meaning.

- You also shouldn’t put && at the very start or very end of the regex. Ruby treats `[0-9&&]` and `[&&0-9]` as intersections with an empty class, which `matches no characters at all`.
  - Java ignores leading and trailing && operators.
  - PowerGREP treats them as literal ampersands.

#### negation `^` takes precedence over intersection `[1234&&[3456]]`
The character class `[^1234&&[3456]]` is both negated and intersected.

  - In Java and PowerGREP, negation takes precedence over intersection.
  - Java and PowerGREP read this regex as `“(not 1234) and 3456”`. Thus in Java and PowerGREP this class is the same as [56] and matches the digits 5 and 6.
  - In Ruby, intersection takes precedence over negation. Ruby reads `[^1234&&3456]` as `“not (1234 and 3456)”`. Thus in Ruby this class is the same as [^34] which matches anything except the digits 3 and 4.

- If you want to negate the right hand side of the intersection, then you must use `square brackets`. Those automatically control precedence.
  - So Java, PowerGREP, and Ruby all read `[1234&&[^3456]]` as `“1234 and (not 3456)”`. Thus this regex is the same as `[12]`.

#### Notational Compatibility with Other Regex Flavors
The ampersand has no special meaning in character classes in any other regular expression flavors discussed in this tutorial. The ampersand is simply a literal, and repeating it just adds needless duplicates. All these flavors treat [1234&&3456] as identical to [&123456].

Strictly speaking, this means that the character class intersection syntax is incompatible with the majority of other regex flavors. But in practice there’s no difference, because there is no point in using two ampersands in a character class when you just want to add a literal ampersand. A single ampersand is still treated as a literal by Java, Ruby, and PowerGREP.

---

## 普通字符 Literal Characters
普通字符包括: 没有显式指定为元字符的所有可打印和不可打印字符。
- 这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。

`/a/`
- string: "Jack is a boy"
- it matches the a after the J.
- a is in the middle of the word does not matter to the regex engine.
- This regex can match the second a too.
- It only does so when you tell the regex engine to start searching through the string after the first match.
  - In a text editor, you can do so by using its “Find Next” or “Search Forward” function.
  - In a programming language, there is usually a separate function that you can call to continue searching through the string after the previous match.

`/cat/ `
- "About cats and dogs"
- matches cat in "About cats and dogs".
- This regular expression consists of a series of three literal characters.
- This is like saying to the regex engine: find a `c`, immediately followed by an `a`, immediately followed by a `t`.

regex engines are case sensitive by default.
- `cat` does not match `Cat`, unless you tell the regex engine to ignore differences in case.

---

## 特殊字符 Special Characters
12 characters with special meanings

    如上面说的 runoo*b 中的 `*`，简单的说就是表示任何字符串的意思。
    如果要查找字符串中的 * 符号，则需要对 * 进行转义，即在其前加一个 `\`: `runo\*ob` 匹配 runo*ob。

正则表达式中的特殊字符：

特别字符 | name | 描述
---|---|---
`$`	    | dollar sign                | 匹配输入字符串的结尾位置。
--------| ---------------------------|设置RegExp对象的 Multiline 属性，则 `$` 也匹配 `\n` 或 `\r`。
`( )`	  | opening/closing parenthesis| 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。
`*`	    | asterisk / star            | 匹配前面的子表达式零次或多次。
`+`	    | plus                       | 匹配前面的子表达式一次或多次。
`.`	    | dot                        | 匹配 `除换行符 \n 之外的任何单字符`。
`[`	    | opening square bracket     | 标记一个中括号表达式的开始。
`?`	    | question mark              | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。
`\`	    | backslash                  | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。
--------| ---------------------------| 例 'n' 匹配字符 'n'。'\n' 匹配换行符。'\\' 匹配 `"\"`。`'\('` 匹配 `"("`。
`^`	    | caret                      | 匹配输入字符串的开始位置，[^xxx]表示不接受该方括号表达式中的xxx字符集合。
`{`	    | opening curly brace        | 标记限定符表达式的开始。
`|`	    | vertical bar / pipe symbol | 指明两项之间的一个选择。`^(a|b)oot`


- 若要匹配这些特殊字符时特别对待。使字符"转义"，将反斜杠字符 `\` 放在它们前面
  - want to use any of these characters as a literal in a regex, escape them with a backslash.
- All other characters should not be escaped with a backslash. That is because the backslash is also a special character. The backslash in combination with a literal character can create a regex token with a special meaning.
  - E.g. \d is a shorthand that matches a single digit from 0 to 9.

```cpp
1+1=2, with the backslash omitted, is a valid regex.

// won’t get an error message.
But it doesn’t match 1+1=2.
It would match 111=2 in 123+111=234, due to the special meaning of the +

// get an error message
where its use is not allowed, such as in +1
```

- Escaping a single metacharacter with a backslash works in all regular expression flavors.
Some flavors also support the \Q…\E escape sequence.
All the characters between the \Q and the \E are interpreted as literal characters.

`\Q*\d+*\E` matches the literal text `*\d+*`.
The \E may be omitted at the end of the regex, so `\Q*\d+*` is the same as `\Q*\d+*\E`.
This syntax is supported by the JGsoft engine, Perl, PCRE, PHP, Delphi, Java, both inside and outside character classes. Java 4 and 5 have bugs that cause \Q…\E to misbehave, however, so you shouldn’t use this syntax with Java. Boost supports it outside character classes, but not inside.

---

### `.` dot

```cpp
// [.] 只会匹配 .字符，等价于 \.，而非匹配除换行符 \n 外的所有字符。
var str = "runoob.com";
var patt1 = /[.]/;
document.write(str.match(patt1));
```

The Dot Matches (Almost) Any Character

The `dot` matches `a single character`, without caring what that character is.

The only exception are `line break` characters.
- In all regex flavors, the dot does not match line breaks by default.
- This exception exists mostly because of historic reasons. The first tools that used regular expressions were line-based. They would read a file line by line, and apply the regular expression separately to each line. The effect is that with these tools, the string could never contain line breaks, so the dot could never match them.

> Modern tools and languages can apply regular expressions to very large strings or even entire files.
>  - Except for JavaScript and VBScript, all regex flavors discussed here have an option to make the dot match all characters, including line breaks.
>  - In PowerGREP, tick the checkbox labeled `“dot matches line breaks”` to make the dot match all characters.
>  - In EditPad Pro, turn on the `“Dot”` or `“Dot matches newline”` search option.
>  - In Perl, the mode where the dot also matches line breaks is called `“single-line mode”`. activate single-line mode by adding an `s` after the regex code, like this:` m/^regex$/s;`.
>    - Multi-line mode only affects `anchors`
>    - single-line mode only affects the `dot`.

Other languages and regex libraries have adopted Perl’s terminology. When using the regex classes of the .NET framework, you activate this mode by specifying `RegexOptions.Singleline`, such as in `Regex.Match`("string", "regex", RegexOptions.Singleline).

>  - JavaScript and VBScript do not have an option to make the `dot` match `line break characters`. In those languages, use a character class such as `[\s\S]` to match any character. This character matches a character that is either a whitespace character (including line break characters), or a character that is not a whitespace character. Since all characters are either whitespace or non-whitespace, this character class matches any character.
>  - In all of Boost’s regex grammars the dot matches line breaks by default. Boost’s ECMAScript grammar allows you to turn this off with regex_constants::no_mod_m.


#### Use The Dot Sparingly
The dot is a very powerful regex metacharacter. everything matches just fine when you test the regex on valid data.
The problem is that the regex also matches in cases where it should not match.

example.

  - to match a date in `mm/dd/yy` format, but want to leave the user the choice of date separators.
    - The quick solution is `\d\d.\d\d.\d\d`.
    - It matches a date like 02/12/03 just fine.
    - 02512703 is also considered a valid date by this regular expression.

  - `\d\d[- /.]\d\d[- /.]\d\d` is a better solution.
    - This regex allows a `dash, space, dot and forward slash` as date separators.
    - the dot is not a metacharacter inside a character class, do not need to escape with a backslash.
    but It matches 99/99/99 as a valid date.

  - `[01]\d[- /.][0-3]\d[- /.]\d\d`
    - but it still matches 19/39/99.

##### example: Matching a Valid Date
`^(19|20)\d\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$` matches a date in yyyy-mm-dd format from 1900-01-01 through 2099-12-31, with a choice of four separators.
  - The anchors make sure the entire variable is a date, and not a piece of text containing a date.
  - The year is matched by `(19|20)\d\d`. `Parentheses ()` are the only way to stop the vertical bar from splitting up the entire regular expression into two options.
  - The month is matched by `0[1-9]|1[012]`, again enclosed by `parentheses()` to keep the two options together. By using character classes, the first option matches a number between 01 and 09, and the second matches 10, 11 or 12.
  - The last part of the regex consists of three options. The first matches the numbers 01 through 09, the second 10 through 29, and the third matches 30 or 31.

but it includ invalid dates such as 2000-00-00 that could not have been excluded without using alternation. To be really perfectionist, you would have to split up the month into various options to take into account the length of the month.
The above regex still matches 2003-02-31, which is not a valid date. Making leading zeros optional could be another enhancement.

to require the delimiters to be consistent
- use a backreference.
- `^(19|20)\d\d([- /.])(0[1-9]|1[012])\2(0[1-9]|[12][0-9]|3[01])$` will match 1999-01-01 but not 1999/01-01.

Again, how complex you want to make your regular expression depends on the data you are using it on, and how big a problem it is if an unwanted match slips through. If you are validating the user’s input of a date in a script, it is probably easier to do certain checks outside of the regex.
For example, excluding February 29th when the year is not a leap year is far easier to do in a scripting language. It is far easier to check if a year is divisible by 4 (and not divisible by 100 unless divisible by 400) using simple arithmetic than using regular expressions.

Here is how you could check a valid date in Perl. I also added parentheses to capture the year into a backreference.

```
sub isvaliddate {
  my $input = shift;
  if ($input =~ m!^((?:19|20)\d\d)[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$!) {
    # At this point, $1 holds the year, $2 the month and $3 the day of the date entered
    if ($3 == 31 and ($2 == 4 or $2 == 6 or $2 == 9 or $2 == 11)) {
      return 0; # 31st of a month with 30 days
    } elsif ($3 >= 30 and $2 == 2) {
      return 0; # February 30th or 31st
    } elsif ($2 == 2 and $3 == 29 and not ($1 % 4 == 0 and ($1 % 100 != 0 or $1 % 400 == 0))) {
      return 0; # February 29th outside a leap year
    } else {
      return 1; # Valid date
    }
  } else {
    return 0; # Not a date
  }
}
```

To match a date in mm/dd/yyyy format, rearrange the regular expression to `^(0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])[- /.](19|20)\d\d$`. For dd-mm-yyyy format, use `^(0[1-9]|[12][0-9]|3[01])[- /.](0[1-9]|1[012])[- /.](19|20)\d\d$`. You can find additional variations of these regexes in RegexBuddy’s library.

---

### `\` backslash
将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。
- 例如，
- 'n' 匹配字符 "n"。'\n' 匹配一个换行符。
- 序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。

### `^` caret
匹配输入字符串的开始位置。
- 如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。

### `$` dollar sign
匹配输入字符串的结束位置。
- 如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。

### `*` asterisk / star
匹配前面的子表达式零次或多次。
- 例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。

### `+` plus
匹配前面的子表达式一次或多次。
- 例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。

### `?` question mark
匹配前面的子表达式零次或一次。
- 例如，"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 {0,1}。

### Special Characters and Programming Languages
If you are a programmer, you may be surprised that characters like the single quote and double quote are not special characters. That is correct. When using a regular expression or grep tool like PowerGREP or the search function of a text editor like EditPad Pro, you should not escape or repeat the quote characters like you do in a programming language.

In your source code, you have to keep in mind `which characters get special treatment inside strings` by your programming language.
- That is because those characters are processed by the compiler, before the regex library sees the string.
- So the regex 1\+1=2 must be written as "1\\+1=2" in C++ code. The C++ compiler turns the escaped backslash in the source code into a single backslash in the string that is passed on to the regex library. To match c:\temp, you need to use the regex c:\\temp. As a string in C++ source code, this regex becomes "c:\\\\temp". Four backslashes to match a single one indeed.


---


## 非打印字符 Non-Printable Characters
非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：

lowercase letters / capital letter

字符	| 描述
---|---
`\cX`	| 匹配由X指明的控制字符。to insert ASCII control characters
------| The letter after the backslash is always a lowercase c
------| X 必须为 A-Za-z 之一。 Only Java requires the A to Z to be uppercase.
------| 否则将 c 视为一个原义的 'c' 字符。
`\cM` | 匹配一个 Control-M 或 carriage return, just like \r, \x0D, and \u000D
------|
`\f`	| 匹配一个换页符。`form feed` (0x0C). 等价于 \x0c 和 \cL。
`\t`	| 匹配一个制表符. `tab` character (ASCII 0x09)。等价于 \x09 和 \cI。
`\v`	| 匹配一个垂直制表符。vertical tab (ASCII 0x0B). 等价于 \x0b 和 \cK。
`\a`  | (bell, 0x07)
`\e`  | (escape, 0x1B)
------|
`\r`	| 匹配一个回车符。`carriage return` (0x0D). 等价于 \x0d 和 \cM。
`\R`  | matches any line break, including Unicode line breaks.
------|
`\s`	| 匹配任何`空白字符`，包括空格、制表符、换页符等等。等价于 `[ \f\n\r\t\v]`。
------| 注意 Unicode 正则表达式会匹配全角空格符。
`\S`	| 匹配任何`非空白字符`。等价于 `[^ \f\n\r\t\v]`。
------|
`\w`  | “word character ASCII characters”. 匹配字母、数字、下划线
`\W`  | 匹配非字母、数字、下划线。等价于 `[^A-Za-z0-9_]`。
------|
`\n`	| 匹配一个换行符。`line feed` (0x0A). 等价于 \x0a 和 \cJ。
------| Windows use `\r\n` to terminate lines, UNIX use `\n`.
`\N`	| matches any single character that is not a line break, like the dot does.

---

### Shorthand Character Classes `[\lowercase letter]`
Since certain character classes are used often, a series of shorthand character classes are available.

### Negated Shorthand Character Classes `[\capital letter]`

1. The above three shorthands also have `negated versions`.
    - `\D` is the same as `[^\d]`
    - `\W` is short for `[^\w]`
    - `\S` is the equivalent of `[^\s]`

2. Be careful when using the `negated shorthands inside square brackets`.
    - `[\D\S]` is not the same as `[^\d\s]`.
      - `[^\d\s]` matches *any character that is neither a digit nor whitespace*.
        - It matches x, but not 8.
      - `[\D\S]` matches *any character that is either not a digit, or is not whitespace*. all digits are not whitespace, and all whitespace characters are not digits,
        - `[\D\S]` matches any character; digit, whitespace, or otherwise.

---

### `\d` [0-9]. 匹配一个数字字符
In most flavors that support Unicode, `\d` includes all `digits` from all scripts.
- Notable exceptions are Java, JavaScript, and PCRE.
- These Unicode flavors match only ASCII digits with `\d`.

### `\w` “word character ASCII characters”. 匹配字母、数字、下划线
It always matches the ASCII characters `[A-Za-z0-9_]`.
- Notice the inclusion of the underscore and digits. In most flavors that support Unicode,
- \w includes many characters from other scripts. There is a lot of inconsistency about which characters are actually included. Letters and digits from alphabetic scripts and ideographs are generally included. Connector punctuation other than the underscore and numeric symbols that aren’t digits may or may not be included.
  - XML Schema and XPath even include *all symbols* in `\w`.
  - Java, JavaScript, and PCRE match *only ASCII characters* with `\w`.

### `\W` 匹配非字母、数字、下划线。
等价于 '[^A-Za-z0-9_]'。

### `\s` “whitespace character”.

`\s` 匹配任何空白字符，包括空格、制表符、换页符等等。
等价于 [ \f\n\r\t\v]。

Again, which characters this actually includes, depends on the regex flavor.
- In all flavors discussed, it includes `[ \t\r\n\f]`.
- matches `a space, a tab, a carriage return, a line/form feed`.

`[\s\S]` match any character.
- This character matches a character that is either a whitespace character (including line break characters), or a character that is not a whitespace character. Since all characters are either whitespace or non-whitespace, this character class matches any character.

- Most flavors also include the vertical tab, with Perl (prior to version 5.18) and PCRE (prior to version 8.34) being notable exceptions.
- In flavors that support Unicode, \s normally includes all characters from the Unicode “separator” category.
- Java and PCRE are exceptions once again.
- But JavaScript does match all Unicode whitespace with \s.

Shorthand character classes can be used both inside and outside the square brackets.
  - \s\d matches a whitespace character followed by a digit.
  - [\s\d] matches a single character that is either whitespace or a digit.
  - When applied to 1 + 2 = 3, the former regex matches ` 2 (space two)`, while the latter matches 1 (one).
  - [\da-fA-F] matches a hexadecimal digit, and is equivalent to [0-9a-fA-F] if your flavor only matches ASCII characters with `\d`.

### `\S` 匹配任何非空白字符。
等价于 [^ \f\n\r\t\v]。

### `\n` Line Break
The tutorial page about the dot already discussed which characters are seen as line break characters by the various regex flavors. This affects the anchors just as much when in multi-line mode, and when the dollar matches before the end of the final break. The anchors handle line breaks that consist of a single character the same way as the dot in each regex flavor.

For anchors there’s an additional consideration when CR and LF occur as a pair and the regex flavor treats both these characters as line breaks. Delphi, Java, and the JGsoft flavor treat CRLF as an indivisible pair. ^ matches after CRLF and $ matches before CRLF, but neither match in the middle of a CRLF pair. JavaScript and XPath treat CRLF pairs as two line breaks. ^ matches in the middle of and after CRLF, while $ matches before and in the middle of CRLF.

### `\N` Never Matches Line Breaks

Perl 5.12 and PCRE 8.10 introduced `\N` which matches any single character that is not a line break, just like the dot does.
- Unlike the dot, `\N` is not affected by “single-line mode”. `(?s)\N.` turns on `single-line mode` and then matches any character that is not a line break followed by any character regardless of whether it is a line break.

PCRE’s options that control which characters are treated as line breaks affect \N in exactly the same way as they affect the dot.

PHP 5.3.4 and R 2.14.0 also support \N as their regex support is based on PCRE 8.10 or later. JGsoft V2 also supports \N.


### `\b`
匹配一个单词边界，也就是指单词和空格间的位置。
- 例如，
- 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。

### `\B`
匹配非单词边界。
- 例如，
- 'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。

### `\cx`
匹配由 x 指明的控制字符。
- 例如，
- \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。


### `\D`
匹配一个非数字字符。等价于 [^0-9]。

### `\f`
匹配一个换页符。等价于 \x0c 和 \cL。

### `\n` 匹配一个换行符。
等价于 \x0a 和 \cJ。

### `\r` 匹配一个回车符。
等价于 \x0d 和 \cM。


### `\t` 匹配一个制表符。
等价于 \x09 和 \cI。

### `\v` 匹配一个垂直制表符。
等价于 \x0b 和 \cK。

### `\xn`
匹配 n，其中 n 为十六进制转义值。
十六进制转义值必须为确定的两个数字长。
- 例如，
- '\x41' 匹配 "A"。
- '\x041' 则等价于 '\x04' & "1"。正则表达式中可以使用 ASCII 编码。

### `\num`
匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。
- 例如
- '(.)\1' 匹配两个连续的相同字符。

### `\n`
标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。

### `\nm`
标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。

### `\nml`
如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。

### `\un`
匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。


### More Shorthand Character Classes
While support for `\d`, `\s`, and `\w` is quite universal, there are some regex flavors that support additional shorthand character classes.

> Perl 5.10 introduced \h and \v.
\h matches horizontal whitespace, which includes the tab and all characters in the “space separator” Unicode category. It is the same as [\t\p{Zs}].
\v matches “vertical whitespace”, which includes all characters treated as line breaks in the Unicode standard. It is the same as [\n\cK\f\r\x85\x{2028}\x{2029}].

> PCRE also supports \h and \v starting with version 7.2.
PHP does as of version 5.2.2, Java as of version 8, and the JGsoft engine as of version 2.
Boost supports \h starting with version 1.42. No version of Boost supports \v as a shorthand.

> In many other regex flavors, \v matches only the vertical tab character. Perl, PCRE, and PHP never supported this, so they were free to give \v a different meaning.
> Java 4 to 7 and JGsoft V1 did use \v to match only the vertical tab.
> Java 8 and JGsoft V2 changed the meaning of this token anyway. The vertical tab is also a vertical whitespace character.
To avoid confusion, the above paragraph uses `\cK` to represent the vertical tab.

> Ruby 1.9 and later have their own version of \h. It matches a single hexadecimal digit just like [0-9a-fA-F]. \v is a vertical tab in Ruby.

### XML Character Classes
XML Schema, XPath, and JGsoft V2 regular expressions support four more shorthands that aren’t supported by any other regular expression flavors.

\i matches any character that may be the first character of an XML name.

\c matches any character that may occur after the first character in an XML name.

\I and \C are the respective negated shorthands. Note that the \c shorthand syntax conflicts with the control character syntax used in many other regex flavors.

You can use these four shorthands both inside and outside character classes using the bracket notation.
They’re very useful for validating XML references and values in your XML schemas.
The regular expression \i\c* matches an XML name like `xml:schema`.

The regex `<\i\c*\s*>` matches an opening XML tag without any attributes. `</\i\c*\s*>` matches any closing tag. `<\i\c*(\s+\i\c*\s*=\s*("[^"]*"|'[^']*'))*\s*>` matches an opening tag with any number of attributes. Putting it all together, `<(\i\c*(\s+\i\c*\s*=\s*("[^"]*"|'[^']*'))*|/\i\c*)\s*>` matches either an opening tag with attributes or a closing tag.

No other regex flavors discussed in this tutorial support XML character classes.

If your XML files are plain ASCII , you can use `[_:A-Za-z] for \i and [-._:A-Za-z0-9]` for `\c`. If you want to allow all Unicode characters that the XML standard allows, then you will end up with some pretty long regexes. You would have to use `[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D
\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD] instead of \i and [-.0-9:A-Z_a-z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D
\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD] instead of \c`.

---

## Anchors 定位符
Anchors are a different breed. They do not match any character at all.
- Instead, they match a position before, after, or between characters.
- They can be used to “anchor” the regex match at a certain position.

将正则表达式固定到行首或行尾。用来描述字符串或单词的边界

正则表达式的定位符有：

字符	| 描述
---|---
`^`	    | 匹配输入字符串`开始`的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。
`$`	    | 匹配输入字符串`结尾`的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。
`\b`	  | 匹配一个`单词边界`，即字与空格间的位置。
`\B`	  | `非单词边界`匹配。

注意：不能将限定符与定位符一起使用。
- 由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。

### `^` and `$` as Start of Line and End of Line Anchors
若要匹配一行文本开始处的文本，在正则表达式的开始使用 ^ 字符。
- 不要将 ^ 的这种用法与中括号表达式内的用法混淆。

若要匹配一行文本的结束处的文本，在正则表达式的结束处使用 $ 字符。

A string consisting of multiple lines: `first line\nsecond line` (`\n` indicates a line break)
- most regex engines discussed in this tutorial have the option to `expand the meaning of both anchors`.
- `^`: match at the start of the string (before the f in the above string), and after each line break (between `\n` and s).
- `$`: matches at the end of the string (after the last e), and before every line break (between e and `\n`).

> In text editors like EditPad Pro or GNU Emacs, and regex tools like PowerGREP, the caret and dollar always match at the start and end of each line. This makes sense because those applications are designed to work with entire files, rather than short strings. In Ruby and std::regex the caret and dollar also always match at the start and end of each line. In Boost they match at the start and end of each line by default. Boost allows you to turn this off with regex_constants::no_mod_m when using the ECMAScript grammar.
> In all other programming languages and libraries discussed on this website , you have to explicitly activate this extended functionality. It is traditionally called “multi-line mode”. In Perl, you do this by adding an m after the regex code, like this: m/^regex$/m;. In .NET, the anchors match before and after newlines when you specify RegexOptions.Multiline, such as in Regex.Match("string", "regex", RegexOptions.Multiline).

1. 若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首：
    - `/^Chapter [1-9][0-9]{0,1}/`

2. 真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它即出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点。
    - `/^Chapter [1-9][0-9]{0,1}$/`

3. 匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。单词边界是单词和空格之间的位置。非单词边界是任何其他位置。`\b` 字符的位置是非常重要的。
    - 如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现在单词边界后面：
    - `/\bCha/`

    - 如果它位于字符串的结尾，它在单词的结尾处查找匹配项。下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在单词边界的前面：
    - `/ter\b/`

4. 下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt：

    - /\Bapt/

    - 字符串 apt 出现在单词 Chapter 中的非单词边界处，但出现在单词 aptitude 中的单词边界处。
    - 对于 \B 非单词边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。

#### `^` 和 `[^指定字符串]` 之间的区别:

^ 指的是匹配字符串开始的位置

[^指定字符串] 指的是除指定字符串以外的其他字符串

      (^[0-9])+     //匹配有一至多个数字的字符串组合
      [^[0-9]]+  // 匹配有一至多个不含数字的字符串组合

### Useful Applications
When using regular expressions in a programming language to validate user input,  anchors is very important.

`if ($input =~ m/\d+/)` in a Perl script to see if the user entered an integer number
- it will accept the input even if the user entered qsdf4ghjk, because `\d+` matches the 4.
- The correct regex to use is `^\d+$`. as “start of string” must be matched before the match of `\d+`, and “end of string” must be matched right after it, the entire string must consist of digits for `^\d+$` to be able to match.

It is easy for the user to accidentally type in a space. When Perl reads from a line from a text file, the line break is also be stored in the variable. So before validating input, it is good practice to trim leading and trailing whitespace.

`^\s+` matches leading whitespace and `\s+$` matches trailing whitespace.
- In Perl, use `$input =~ s/^\s+|\s+$//g`. Handy use of alternation and `/g` allows us to do this in a single line of code.

---

## 限定符
限定符用来指定正则表达式的一个给定组件必须要`出现多少次`才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。

正则表达式的限定符有：

字符	| 描述 | ex
---|---|---
`*`	    | 匹配前面的子表达式`零次或多次`。     | 例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。
`+`	    | 匹配前面的子表达式`一次或多次`。     | 例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
`?`	    | 匹配前面的子表达式`零次或一次`。     | 例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。
`{n}`	  | n 是一个非负整数。匹配确定的 n 次。  | 例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
`{n,}`	| n 是一个非负整数。至少匹配 n 次。    | 例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。
`{n,m}`	| m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。| 例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。

```py
以下正则表达式匹配一个正整数
[1-9]设置第一个数字不是 0，
[0-9]* 表示任意多个数字：

/[1-9][0-9]*/

# 0 not selected
1
10
123
1234

- 限定符出现在范围表达式之后。因此，它应用于整个范围表达式，在本例中，只指定从 0 到 9 的数字（包括 0 和 9）。
- 不使用 + 限定符，因为在第二个位置或后面的位置不一定需要有一个数字。
- 不使用 ? 字符，因为使用 ? 会将整数限制到只有两位数。


如果设置 0~99 的两位数，
- 用下面的表达式来至少指定一位但至多两位数字。

/[0-9]{1,2}/


上面的表达式的缺点是，只能匹配两位数字，而且可以匹配 0、00、01、10 99 的章节编号仍只匹配开头两位数字。
- 改进下，匹配 1~99 的正整数表达式如下：

/[1-9][0-9]?/
或
/[1-9][0-9]{0,1}/
```

`*、+` 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 `?` 就可以实现`非贪婪`或`最小匹配`。

```xml
例如，搜索 HTML 文档，以查找在 h1 标签内的内容。
HTML 代码如下：

<h1>RUNOOB-菜鸟教程</h1>

贪婪：匹配从开始小于符号 (<) 到关闭 h1 标记的大于符号 (>) 之间的所有内容: <h1>RUNOOB-菜鸟教程</h1>。
/<.*>/


非贪婪：只匹配开始和结束 h1 标签，下面的非贪婪表达式只匹配: <h1>。
/<.*?>/


也可以使用以下正则表达式来匹配 h1 标签，表达式则是：
/<\w+?>/
```

## 选择
用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用`?:`放在第一个选项前来消除这种副作用。

其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。

## 反向引用
对一个正则表达式模式 或部分模式 两边添加圆括号 将 导致相关匹配 存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。
- 缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。
- 每个缓冲区都可以使用 \n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。

可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。

反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例：

Is is the cost of of gasoline going up up?

上面的句子很显然有多个重复的单词。如果能设计一种方法定位该句子，而不必查找每个单词的重复出现，那该有多好。下面的正则表达式使用单个子表达式来实现这一点：

实例
查找重复的单词：

var str = "Is is the cost of of gasoline going up up";
var patt1 = /\b([a-z]+) \1\b/ig;
document.write(str.match(patt1));

- 捕获的表达式，正如 [a-z]+ 指定的，包括一个或多个字母。
- 正则表达式的第二部分是对以前捕获的子匹配项的引用，即，单词的第二个匹配项正好由括号表达式匹配。\1 指定第一个子匹配项。
- 单词边界元字符确保只检测整个单词。否则，诸如 "is issued" 或 "this is" 之类的词组将不能正确地被此表达式识别。
- 正则表达式后面的全局标记 `g` 指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。
- 表达式的结尾处的不区分大小写 `i` 标记指定不区分大小写。

多行标记指定换行符的两边可能出现潜在的匹配。


`反向引用`还可以将通用资源指示符 (URI) 分解为其组件。

```xml
假定您想将下面的 URI 分解为协议（ftp、http 等等）、域地址和页/路径：
- `http://www.runoob.com:80/html/html-tutorial.html`

输出所有匹配的数据：

var str = "http://www.runoob.com:80/html/html-tutorial.html";
var patt1 = /(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/;
arr = str.match(patt1);
for (var i = 0; i < arr.length ; i++) {
    document.write(arr[i]);
    document.write("<br>");
}

第三行代码 str.match(patt1) 返回一个数组，实例中的数组包含 5 个元素，索引 0 对应的是整个字符串，索引 1 对应第一个匹配符（括号内），以此类推。

第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。

第二个括号子表达式捕获地址的域地址部分。子表达式匹配非 : 和 / 之后的一个或多个字符。

第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。

最后，第四个括号子表达式捕获 Web 地址指定的路径和 / 或页信息。该子表达式能匹配不包括 # 或空格字符的任何字符序列。

将正则表达式应用到上面的 URI，各子匹配项包含下面的内容：

第一个括号子表达式包含 http
第二个括号子表达式包含 www.runoob.com
第三个括号子表达式包含 :80
第四个括号子表达式包含 /html/html-tutorial.html

```

### example
#### 时分的正则表达式

用来匹配 xx:xx (如：18:26) 格式时间正则:

^([01]\d|2[01234]):([0-5]\d|60)$

#### 2

re.sub(r'(\b[A-z]+) \1',r'\1','Cat In The The Hat')
使用上面的正则会输出: Cat In The Hat

如果把里面的 + 换成 *，如：

re.sub(r'(\b[A-z]*) \1',r'\1','Cat In The The Hat')
则输出: CatInTheHat

原因是：* 表示左边的字符出现 0 次或多次，这样正则就能匹配到 \b+ 空格 +\b 的字符,并且将其替换为 \b。也就是说删除掉 \b+ 空格。相当于去掉空格，合并 2 个单词边界为 1 个。


---

## 正则表达式 - 元字符

### `\`
将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。
- 例如，
- 'n' 匹配字符 "n"。'\n' 匹配一个换行符。
- 序列 '\\' 匹配 "\" 而 "\(" 则匹配 "("。

### `^`
匹配输入字符串的开始位置。
- 如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\n' 或 '\r' 之后的位置。

### `$`
匹配输入字符串的结束位置。
- 如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '\n' 或 '\r' 之前的位置。

### `*`
匹配前面的子表达式零次或多次。
- 例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。

### `+`
匹配前面的子表达式一次或多次。
- 例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。

### `?`
匹配前面的子表达式零次或一次。
- 例如，"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 {0,1}。

### `{n}`
n 是一个非负整数。匹配确定的 n 次。
- 例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。

### `{n,}`
n 是一个非负整数。至少匹配n 次。
- 例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。

### `{n,m}`
m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。
- 例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。

### `?`
当该字符紧跟在任何一个其他限制符 `(*, +, ?, {n}, {n,}, {n,m})` 后面时，匹配模式是非贪婪的。
- 非贪婪模式尽可能少的匹配所搜索的字符串，
- 默认的贪婪模式则尽可能多的匹配所搜索的字符串。
- 例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。

### `.`
匹配除换行符（\n、\r）之外的任何单个字符。
- 要匹配包括 '\n' 在内的任何字符，请使用像"(.|\n)"的模式。

### `(pattern)` 匹配 pattern 并获取这一匹配。
- 所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。
- 要匹配圆括号字符，请使用 '\(' 或 '\)'。

### `(?:pattern)` 匹配 pattern *但不获取匹配结果*
- 一个非获取匹配，不进行存储供以后使用。
- 这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。
- 例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。

### `XXX(?=pattern)` 正向肯定预查（look ahead positive assert）
- 在任何匹配pattern的字符串开始处匹配查找字符串。
- 一个非获取匹配，也就是说，该匹配不需要获取供以后使用。
- 例如，
- `Windows(?=95|98|NT|2000)`能匹配"Windows2000"中的"Windows"，但不能匹配"Windows3.1"中的"Windows"。
- 预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。

### `(?!pattern)`
正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。
这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。
- 例如
- "Windows(?!95|98|NT|2000)"能匹配"Windows3.1"中的"Windows"，但不能匹配"Windows2000"中的"Windows"。
- 预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。

### `(?<=pattern)XXX` 反向(look behind)肯定预查
- 与正向肯定预查类似，只是方向相反。
- 例如
- "(?<=95|98|NT|2000)Windows"能匹配"2000Windows"中的"Windows"，但不能匹配"3.1Windows"中的"Windows"。

#### (?=xox) 和 (?<=xox) 的区别：
可以看作此两者是匹配字符之间的一个虚无的 “空位”。
(?=xox) 匹配 xox 之前的空位，而 (?<=xox) 匹配 xox 之后的空位。

所以对于 abxoxcd：
- (?=xox)..    匹配 xo
- ..(?=xox)    匹配 ab
- (?<=xox)..    匹配 cd
- ..(?<=xox)    匹配 ox

`?=、?!、?<= ?<!` 用于限定它前后的表达式，不能单独使用，本身没有作用。

 a(?=b) 匹配后面有 b 的 a。
 a(?!b) 匹配后面没有 b 的 a。
 (?<=a) b 匹配前面有 a 的 b。
 (?<!a) b 匹配前面没有 a 的 b。

描述 ?=、?!、?<= ?<! 的 “Positive/Negative lookahead/lookbehind assest” 的现行翻译“正先行断言”“正向肯定预查”之类，都不易理解或者说不准确甚至错误。

lookaround 指前后看而不是“预查”，意为作用于前后表达式，即 lookahead(指向前看而不是“先行”)和 lookbehind(指向后看而不是“后发”)的合称；
assert 指判断而不是“断言”；
Positive 和 Negative 指肯否定而不是正负。



### `(?<!pattern)`
反向否定预查，与正向否定预查类似，只是方向相反。
- 例如
- "(?<!95|98|NT|2000)Windows"能匹配"3.1Windows"中的"Windows"，但不能匹配"2000Windows"中的"Windows"。

### `x|y`
匹配 x 或 y。
- 例如，
- 'z|food' 能匹配 "z" 或 "food"。
- '(z|f)ood' 则匹配 "zood" 或 "food"。

### `[xyz]`
字符集合。匹配所包含的任意一个字符。
- 例如，
- '[abc]' 可以匹配 "plain" 中的 'a'。

### [`^`xyz]
负值字符集合。匹配未包含的任意字符。
- 例如，
- '[^abc]' 可以匹配 "plain" 中的'p'、'l'、'i'、'n'。

### `[a-z]`
字符范围。匹配指定范围内的任意字符。
- 例如，
- '[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。

### [`^`a-z]
负值字符范围。匹配任何不在指定范围内的任意字符。
- 例如，
- '[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。

---

## 正则表达式 - 运算符优先级
正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。

相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：

运算符	| 描述
---|---
`\`	                               | 转义符
`(), (?:), (?=), []`	             | 圆括号和方括号
`*, +, ?, {n}, {n,}, {n,m}`	       | 限定符
`^, $, \任何元字符、任何字符`	        | 定位点和序列（即：位置和顺序）
`|`	                               | 替换，"或"操作
-----------------------------------| 字符具有高于替换运算符的优先级，使得`"m|food"`匹配"m"或"food"。
-----------------------------------| 要匹配"mood"或"food": `"(m|f)ood"`

---

## 正则表达式 - 匹配规则

### 基本模式匹配
一切从最基本的开始。
`模式`，是正则表达式最基本的元素，它们是一组描述字符串特征的字符。
模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。

```cpp
例如：

^once
^: 表示该模式只匹配那些以once开头的字符串。
例如该模式:
与字符串"once upon a time"匹配，
与"There once was a man from NewYork"不匹配。

bucket$
$: 配那些以给定模式结尾的字符串。
这个模式:
与"Who kept all of this cash in a bucket"匹配
与"buckets"不匹配。


字符 ^ 和 $ 同时使用时，表示精确匹配（字符串与模式一样）。
^bucket$
只匹配字符串"bucket"。


如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。
例如：模式
once
与字符串 "There once was a man from NewYork" and "Who kept all of his cash in a bucket." 是匹配的。

在该模式中的字母(o-n-c-e)是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。


其他一些稍微复杂的字符，如标点符号和白字符（空格、制表符等），要用到转义序列。
所有的转义序列都用反斜杠"(\)"打头。
- \n表示"新行"，\r表示回车。
- 反斜杠本身用\\表示，
- 句号.用\.

制表符的转义序列是 \t。检测一个字符串是否以制表符开头，可以用这个模式：
^\t
```

### 字符簇 `[a-z]`
在INTERNET的程序中，正则表达式通常用来验证用户的输入。当用户提交一个FORM以后，要判断输入的电话号码、地址、EMAIL地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。

所以要用一种更自由的描述我们要的模式的办法，它就是`字符簇`。

```cpp
要建立一个表示所有元音字符的字符簇，就把所有的元音字符放在一个方括号里：
[AaEeIiOoUu]
- 这个模式与任何元音字符匹配，但只能表示一个字符。


用连字号可以表示一个字符的范围，如：
[a-z]         //匹配所有的小写字母
[A-Z]         //匹配所有的大写字母
[a-zA-Z]      //匹配所有的字母
[0-9]         //匹配所有的数字
[0-9\.\-]     //匹配所有的数字，句号和减号
[ \f\r\t\n]   //匹配所有的白字符
同样的，这些也只表示一个字符，这是一个非常重要的。


如果要匹配一个由一个小写字母和一位数字组成的字符串，比如"z2"、"t6"或"g7"，但不是"ab2"、"r2d3" 或"b52"的话，用这个模式：
^[a-z][0-9]$
尽管[a-z]代表26个字母的范围，但在这里它只能与第一个字符是小写字母的字符串匹配。


^: 表示字符串的开头，但它还有另外一个含义。
当在一组方括号里使用 ^ 时，它表示"非"或"排除"的意思，常常用来剔除某个字符。

例子

要求第一个字符不能是数字：
^[^0-9][0-9]$
- 这个模式与"&5"、"g7"及"-2"是匹配的
- 与"12"、"66"是不匹配的。

排除特定字符的例子：
[^a-z]     //除了小写字母以外的所有字符
[^\\\/\^]  //除了(\)(/)(^)之外的所有字符
[^\"\']    //除了双引号(")和单引号(')之外的所有字符


特殊字符 .(点，句号)在正则表达式中用来表示除了"新行"之外的所有字符。

^.5$
- 与任何两个字符的、以数字5结尾和以其他非"新行"字符开头的字符串匹配。

.
- 可以匹配任何字符串，除了空串和只包括一个"新行"的字符串。
```


PHP的正则表达式有一些内置的`通用字符簇`，列表如下：

字符簇	描述
[[:alpha:]]	任何字母
[[:digit:]]	任何数字
[[:alnum:]]	任何字母和数字
[[:space:]]	任何空白字符
[[:upper:]]	任何大写字母
[[:lower:]]	任何小写字母
[[:punct:]]	任何标点符号
[[:xdigit:]]	任何16进制的数字，相当于[0-9a-fA-F]

---

### 确定重复出现 `{x,y}`
到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。
一个单词有若干个字母组成，一组数字有若干个单数组成。
跟在字符或字符簇后面的花括号`{}`用来确定`前面的内容的重复出现的次数`。

字符簇	| 描述
---|---
`^[a-zA-Z_]$`	      | 所有的字母和下划线
`^[[:alpha:]]{3}$`	| 所有的3个字母的单词
`^a$`	              | 字母a
`^a{4}$`	          | aaaa
`^a{2,4}$`	        | aa,aaa或aaaa
`^a{1,3}$`	        | a,aa或aaa
`^a{2,}$`	          | 包含多于两个a的字符串
`^a{2,}`	          | 如：aardvark和aaab，但apple不行
`a{2,}`	            | 如：baad和aaa，但Nantucket不行
`\t{2}	`           | 两个制表符
`.{2}`	            | 所有的两个字符

这些例子描述了花括号的三种不同的用法。
- {x} 的意思是前面的字符或字符簇只出现x次 ；
- {x,} 的意思是前面的内容出现x或更多的次数 ；
- {x,y} 表示 前面的内容至少出现x次，但不超过y次。


### `? 与 {0,1}` `* 与 {0,}` `+ 与 {1,}`
把模式扩展到更多的单词或数字：

```cpp
// 所有包含一个以上的字母、数字或下划线的字符串
- ^[a-zA-Z0-9_]{1,}$      

// 所有的正整数
- ^[1-9][0-9]{0,}$   

// 所有的整数
- ^\-{0,1}[0-9]{1,}$      

// 所有的浮点数
- "^[-]?[0-9]+\.?[0-9]+$"

  - 以一个可选的负号 "[-]?" 开头 ^
  - 跟着1个或更多的数字([0-9]+)、和一个小数点(\.)再跟上1个或多个数字([0-9]+)，
  - 并且后面没有其他任何东西($)。
```


- 字符 `?` 与 {0,1} 是相等的： 0个或1个前面的内容 或 前面的内容是可选的 。
  - 所以刚才的例子可以简化为：
  - "^\-?[0-9]{1,}\.?[0-9]{1,}$"

- 字符 * 与 {0,} 是相等的: 代表着 0 个或多个前面的内容 。
- 字符 + 与 {1,} 是相等的: 表示 1 个或多个前面的内容 ，
  - 所以上面的4个例子可以写成：

  - `^[a-zA-Z0-9_]+$ `     // 所有包含一个以上的字母、数字或下划线的字符串
  - `^[1-9][0-9]*$`        // 所有的正整数
  - `^\-?[0-9]+$`          // 所有的整数
  - `^[-]?[0-9]+(\.[0-9]+)?$` // 所有的浮点数

- 并不能从技术上降低正则表达式的复杂性，但可以使它们更容易阅读。


### 正则表达式中 [] 和 () 的区别

圆括号 `()` 是组，主要应用在限制多选结构的范围/分组/捕获文本/环视/特殊模式处理。

1. (abc|bcd|cde)：abc、bcd、cde三者之一均可，顺序也必须一致。
2. (abc)?：表示这一组要么一起出现，要么不出现，出现则按此组内的顺序出现。
3. (?:abc)：表示找到这样abc这样一组，但不记录，不保存到$变量中，否则可以通过$x取第几个括号所匹配到的项，比如：(aaa)(bbb)(ccc)(?:ddd)(eee)，可以用 $1 获取 (aaa) 匹配到的内容，而 $3 则获取到了 (ccc) 匹配到的内容，而 $4 则获取的是由 (eee) 匹配到的内容，因为前一对括号没有保存变量。
4. `a(?=bbb)`：顺序环视 表示 a 后面必须紧跟 3 个连续的 b。
5. `(?i:xxxx)`：不区分大小写 `(?s:.*)` 跨行匹配.可以匹配回车符。


方括号 `[]` 是单个匹配，字符集/排除字符集/命名字符集。

1. [0-3]：表示找到这一个位置上的字符只能是 0 到 3 这四个数字，与 (abc|bcd|cde) 的作用比较类似，但`圆括号可以匹配多个连续的字符`，而`一对方括号只能匹配单个字符`。
2. [^0-3]：表示找到这一个位置上的字符`只能是除了 0 到 3 之外的所有字符`。

() 和 [] 有本质的区别
- `()` 内的内容表示的是一个子表达式，() 本身不匹配任何东西，也不限制匹配任何东西，只是把括号内的内容作为同一个表达式来处理，
  - 例如
  - `(ab){1,3}`: 表示 ab 一起连续出现最少 1 次，最多 3 次。
  - 没有括号 `ab{1,3}`: 就表示 a，后面紧跟的 b 出现最少 1 次，最多 3 次。
  - 括号在匹配模式中也很重要。

- `[]` 表示匹配的字符在 [] 中，并且只能出现一次，并且特殊字符写在 [] 会被当成普通字符来匹配。
  - 例如 [(a)]，会匹配 `(`、`a`、`)`、这三个字符。

- ()、[] 无论是作用还是表示的含义，都有天壤之别。

---

## 正则表达式 - 示例

### 简单表达式
在搜索字符串中匹配其本身的`单个普通字符`。
- 例如，单字符模式，如 A，不论出现在搜索字符串中的何处，它总是匹配字母 A。

      /a/
      /7/
      /M/

- 将许多`单字符`组合起来以形成大的表达式。
- 例如，以下正则表达式组合了单字符表达式：a、7 和 M。

      /a7M/

- 没有串联运算符。只须在一个字符后面键入另一个字符。

### 字符匹配
句点 (.) 匹配字符串中的各种打印或非打印字符，只有一个字符例外。换行符 (\n)。
- 下面的正则表达式匹配 aac、abc、acc、adc 等等，以及 a1c、a2c、a-c 和 a#c：

      /a.c/

- 若句点 (.) 是输入字符串的组成部分，句点前面加反斜杠 (\) 字符。
- 举例来说明，匹配包含文件名的字符串，filename.ext：

      /filename\.ext/


### 中括号表达式
- 创建匹配字符组的一个列表，在方括号 `[ ]` 内放置一个或更多单个字符。当字符括在中括号内时，该列表称为"中括号表达式"。
- 与在任何别的位置一样，普通字符在中括号内表示其本身，即，它在输入文本中匹配一次其本身。
- 大多数特殊字符在中括号表达式内出现时失去它们的意义。不过也有一些例外，如：

如果 ] 字符不是第一项，它结束一个列表。若要匹配列表中的 ] 字符，请将它放在第一位，紧跟在开始 [ 后面。
\ 字符继续作为转义符。若要匹配 \ 字符，请使用 \\。

- 括在中括号表达式中的字符只匹配处于正则表达式中该位置的单个字符。

- 以下正则表达式匹配 Chapter 1、Chapter 2、Chapter 3、Chapter 4 和 Chapter 5：

/Chapter [12345]/

- 单词 Chapter 和后面的空格的位置相对于中括号内的字符是固定的。
- 中括号表达式指定的只是匹配紧跟在单词 Chapter 和空格后面的单个字符位置的字符集。第九个字符位置。

- 若要使用范围代替字符本身来表示匹配字符组，使用连字符 (-) 将范围中的开始字符和结束字符分开。单个字符的字符值确定范围内的相对顺序。
- 下面的正则表达式包含范围表达式，该范围表达式等效于上面显示的中括号中的列表。

/Chapter [1-5]/

- 当以这种方式指定范围时，开始值和结束值两者都包括在范围内。注意，还有一点很重要，按 Unicode 排序顺序，开始值必须在结束值的前面。

若要在中括号表达式中包括连字符，请采用下列方法之一：

```cpp
// 用反斜杠将它转义：
[\-]

// 将连字符放在中括号列表的开始或结尾。下面的表达式匹配所有小写字母和连字符：
[-a-z]
[a-z-]

// 创建一个范围，在该范围中，开始字符值小于连字符，而结束字符值等于或大于连字符。
// 下面的两个正则表达式都满足这一要求：
[!--]
[!-~]


// 若要查找不在列表或范围内的所有字符，请将插入符号 (^) 放在列表的开头。
// 如果插入字符出现在列表中的其他任何位置，则它匹配其本身。
// 下面的正则表达式匹配1、2、3、4 或 5 之外的任何数字和字符：

/Chapter [^12345]/
//例如，Chapter 7 就是一个匹配项，Chapter 9 也是一个匹配项。

// 上面的表达式可以使用连字符 (-) 来表示：
/Chapter [^1-5]/


中括号表达式的典型用途是指定"任何大写或小写字母或任何数字"的匹配。下面的表达式指定这样的匹配：

/[A-Za-z0-9]/
```

### 替换和分组 `|`
替换使用 | 字符来允许在两个或多个替换选项之间进行选择。
- 例如，可以扩展章节标题正则表达式，以返回比章标题范围更广的匹配项。
- 替换匹配 | 字符任一侧最大的表达式。

您可能认为，下面的表达式匹配出现在行首和行尾、后面跟一个或两个数字的 Chapter 或 Section：

/^Chapter|Section [1-9][0-9]{0,1}$/
很遗憾，上面的正则表达式要么匹配行首的单词 Chapter，要么匹配行尾的单词 Section 及跟在其后的任何数字。
- 如果输入字符串是 Chapter 22，那么上面的表达式只匹配单词 Chapter。
- 如果输入字符串是 Section 22，那么该表达式匹配 Section 22。

若要使正则表达式更易于控制，可以使用括号来限制替换的范围，即，确保它只应用于两个单词 Chapter 和 Section。
- 但是，括号也用于创建子表达式，并可能捕获它们以供以后使用，这一点在有关反向引用的那一节讲述。通过在上面的正则表达式的适当位置添加括号，就可以使该正则表达式匹配 Chapter 1 或 Section 3。

下面的正则表达式使用括号来组合 Chapter 和 Section，以便表达式正确地起作用：

/^(Chapter|Section) [1-9][0-9]{0,1}$/

尽管这些表达式正常工作，但 `Chapter|Section` 周围的括号还将捕获两个匹配字中的任一个供以后使用。
- 由于在上面的表达式中只有一组括号，因此，只有一个被捕获的"子匹配项"。

在上面的示例中，您只需要使用括号来组合单词 Chapter 和 Section 之间的选择。若要`防止匹配被保存以备将来使用`，在括号内正则表达式模式之前放置 ?:。
- 下面的修改提供相同的能力而不保存子匹配项：

/^(?:Chapter|Section) [1-9][0-9]{0,1}$/

除 ?: 元字符外，两个其他非捕获元字符创建被称为"预测先行"匹配的某些内容。正向预测先行使用 ?= 指定，它匹配处于括号中匹配正则表达式模式的起始点的搜索字符串。反向预测先行使用 ?! 指定，它匹配处于与正则表达式模式不匹配的字符串的起始点的搜索字符串。

- 例如:

一个文档，该文档包含指向 Windows 3.1、Windows 95、Windows 98 和 Windows NT 的引用
需要更新该文档，将指向 Windows 95、Windows 98 和 Windows NT 的所有引用更改为 Windows 2000。
下面的正则表达式（这是一个正向预测先行的示例）匹配 Windows 95、Windows 98 和 Windows NT：
/Windows(?=95 |98 |NT )/

找到一处匹配后，紧接着就在匹配的文本（不包括预测先行中的字符）之后搜索下一处匹配。例如，如果上面的表达式匹配 Windows 98，将在 Windows 之后而不是在 98 之后继续搜索。

## 其他示例

// 一个单词连续出现的位置。
`/\b([a-z]+) \1\b/gi	`

// 将一个URL解析为协议、域、端口及相对路径。
`/(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/`

// 定位章节的位置。
/^(?:Chapter|Section) [1-9][0-9]{0,1}$/

// a至z共26个字母再加一个-号。
/[-a-z]/

// 可匹配chapter，而不能匹配terminal。
/ter\b/

// 可匹配chapter，而不能匹配aptitude。
/\Bapt/

// 可匹配Windows95或Windows98或WindowsNT，当找到一个匹配后，从Windows后面开始进行下一次的检索匹配。
/Windows(?=95 |98 |NT )/

// 匹配空行。
/^\s*$/

// 验证由两位数字、一个连字符再加 5 位数字组成的 ID 号。
/\d{2}-\d{5}/

//匹配 HTML 标记。
/<\s*(\S+)(\s[^>]*)?>[\s\S]*<\s*\/\1\s*>/




























.

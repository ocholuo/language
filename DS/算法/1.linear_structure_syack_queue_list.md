
# algorithms

[toc]

---


## 1

Hilbert's `finite standpoint`

virtual turnning.

what: tree
why: conditional statement
how: loop

a | b
---|---
抽象 | 实现
逻辑 | 物理
接口 | 实现 implemen

bulid in function: procedural abstraction

算法+数据结果=编程

primitive data typr: int, str....

ADT: abstract data type: 抽象数据 (user descript / cover the data)

![Screen Shot 2020-05-25 at 23.25.42](https://i.imgur.com/cJRDWnA.png)

逻辑层面稳定，操作接口不一样，物理不一样

coding:
- c
  - compile
  - link
  - execute
- python
  - run

---

## 2 算法分析

variable name define info.
存储空间
执行时间: import time: time.time()=8888888

1-100:
range(n):

1. O(n):
2. O(n log(n))
3. 暴力法
4. 计数比较：计算字母次数

![Screen Shot 2020-05-26 at 00.32.28](https://i.imgur.com/3Fma2jK.png)


![Screen Shot 2020-05-26 at 00.43.30](https://i.imgur.com/1FedT9U.png)


### linear structure

唯一前后，左右 前后，
- 添加，去除，插入
- stack, queue, deque, list


---

## 3 基本结构 - stack

stack
- top and bottom
- change from one side.
- LIFO: last in first out.
  - base on the storage time. long - bottom, short -top.
- empty, push, pop

![Screen Shot 2020-05-26 at 14.28.21](https://i.imgur.com/viZ9E8J.png)

![Screen Shot 2020-05-26 at 14.29.19](https://i.imgur.com/rTL2FM6.png)


python 实现 ADT stack
- 将 ADT stack 实现为 python class
- 将 ADT stack的操作 实现为 python class 的方法


```py
class Stack:
    def __init__(self):
        self.items = []

    def isEmpty(self):
        return self.items == []

    def push(self, item):
        self.items.append(item)

    def pop(self):
        return self.items.pop()

    def peek(self):
        return self.items[len(self.items)-1]
        return self.items[-1]

    def size(self):
        return len(self.items)

from pythonds.basic.stack import Stack
s = Stack()
```

![Screen Shot 2020-05-26 at 14.45.22](https://i.imgur.com/uxkuJEi.png)


### 10 to 2

(233)10 = (11101001)2
- (233)10 = 2x10^2 + 3x10^1 + 3x10^0
- (11101001)2 = 1x2^7 + 1x2^6 + 1x2^5 +...+ 1x2^0

![Screen Shot 2020-05-26 at 15.26.23](https://i.imgur.com/O1HiGur.png)

```py
from pythonds.basic.stack import Stack

def baseConverter(decNumber):
    digits = "0123456789ABCDEF"
    remstack = Stack()
    while decNumber > 0:
        rem = decNumber % base
        remstack.push(rem)
        decNumber = decNumber // base
    newString = ""
    while not remstack.isEmpty:
#      binString = binString + str(remstack.pop())
    newString = newString +  digits[remstack.pop()]
    return newString
```

---

### 表达式转换

operator
- 优先级，括号
- 全括号表达式
- 前缀`(*+ABC)`，后缀`(AB+C*)`，中缀`(A+B)*C`

![Screen Shot 2020-05-26 at 16.02.12](https://i.imgur.com/YlduKeO.png)

![Screen Shot 2020-05-26 at 16.05.36](https://i.imgur.com/XHTifZt.png)

中缀转后缀：
- 中缀表达式 转换成 单词列表 `token list`
  - A+B*C -> .split() -> ["A", "+", "B", "`*`", "C"] -> .join()

```py
def infixToPostfix(infixexpr):
    prec = {}
    prec["*"] = 3
    prec["/"] = 3
    prec["+"] = 2
    prec["-"] = 2
    prec["("] = 1

    opStack = Stack()
    postfixList = []
    # print(infixexpr)
    tokenList = infixexpr.split()

    for token in tokenList:
        if token in "ABCDEFGHIGKLMNOPQRSTUVWXYZ" or token in "0123456789":
            postfixList.append(token)
            # print("postfixList =", postfixList)
            # print("opStack = []", opStack.items)
        elif token == "(":
            opStack.push(token)
            # print("postfixList =", postfixList)
            # print("opStack = []", opStack.items)
        elif token == ")":
            topToken = opStack.pop()
            while topToken != "(":
                postfixList.append(topToken)
                topToken = opStack.pop()
            # print("postfixList =", postfixList)
            # print("opStack = []", opStack.items)
        else:
            while (not opStack.isEmpty()) and (prec[opStack.peek()] >= prec[token]):
                 postfixList.append(opStack.pop())
            opStack.push(token)
            # print("postfixList =", postfixList)
            # print("opStack = []", opStack.items)

    while not opStack.isEmpty():
        postfixList.append(opStack.pop())

    # print(" ".join(postfixList))
    return " ".join(postfixList)
```

![Screen Shot 2020-05-26 at 16.14.09](https://i.imgur.com/0YrClqi.png)


```py
A * B + C * D
postfixList = ['A']
opStack = [] []
postfixList = ['A', 'B']
opStack = [] ['*']
postfixList = ['A', 'B', '*', 'C']
opStack = [] ['+']
postfixList = ['A', 'B', '*', 'C', 'D']
opStack = [] ['+', '*']
A B * C D * +


A * B * ( A + B ) + C * D
postfixList = ['A']
opStack = [] []
postfixList = ['A']
opStack = [] ['*']
postfixList = ['A', 'B']
opStack = [] ['*']
postfixList = ['A', 'B', '*']
opStack = [] ['*']
postfixList = ['A', 'B', '*']
opStack = [] ['*', '(']
postfixList = ['A', 'B', '*', 'A']
opStack = [] ['*', '(']
postfixList = ['A', 'B', '*', 'A']
opStack = [] ['*', '(', '+']
postfixList = ['A', 'B', '*', 'A', 'B']
opStack = [] ['*', '(', '+']
postfixList = ['A', 'B', '*', 'A', 'B', '+']
opStack = [] ['*']
postfixList = ['A', 'B', '*', 'A', 'B', '+', '*']
opStack = [] ['+']
postfixList = ['A', 'B', '*', 'A', 'B', '+', '*', 'C']
opStack = [] ['+']
postfixList = ['A', 'B', '*', 'A', 'B', '+', '*', 'C']
opStack = [] ['+', '*']
postfixList = ['A', 'B', '*', 'A', 'B', '+', '*', 'C', 'D']
opStack = [] ['+', '*']
A B * A B + * C D * +
```

后缀计算

```py
def doMath(op, numl, numr):
    if op == "+":
        result = int(numl) + int(numr)
    elif op == "*":
        result = int(numl) * int(numr)  
    elif op == "-":
        result = int(numl) - int(numr)              
    elif op == "/":
        result = int(numl) / int(numr)
    else:
        result = "error"
    return result


def postfixEval(postfixExpr):
    operandStack = Stack()
    tokenList = postfixExpr.split()
    # print(tokenList)

    for token in tokenList:
        if token in "0123456789":
            operandStack.push(token)
            # print(operandStack.items)
        else:
            numr = operandStack.pop()
            numl = operandStack.pop()
            newnum = doMath(token, numl, numr)
            operandStack.push(newnum)
            # print(operandStack.items)
    return operandStack.items
    return operandStack.pop()

infixToPostfix ("2 + 4 * 2 - 3")
# 2+4*2-3=7

postfixEval("2 4 2 * + 3 -")
2 4 2 * + 3 -
['2', '4', '2', '*', '+', '3', '-']
['2']
['2', '4']
['2', '4', '2']
['2', 8]
[10]
[10, '3']
[7]

```


---

## 4 线性结构

栈：先进先出，操作较快；缺点：查询慢，读非栈顶数值需要遍历

队列：先进后出，同样操作较快；缺点：读取内部数值需要遍历

表list：可以根据索引取值；缺点：插入和删除是O(n)的

![Screen Shot 2020-05-27 at 17.33.48](https://i.imgur.com/A4GXdUf.png)

![Screen Shot 2020-05-27 at 17.34.09](https://i.imgur.com/w1SEFHH.png)

![Screen Shot 2020-05-27 at 17.35.05](https://i.imgur.com/qDjs9OT.png)

### 队列 queue 先进先出

queue
- FIFO: first in first out.
- only change from 2 side. no insert
  - front : rear


![Screen Shot 2020-05-26 at 22.35.29](https://i.imgur.com/Yqex15c.png)


```py
class Queue:
    def __init__(self):
        self.items = []

    def isEmpty(self):
        return self.itmes == []

    def enqueue(self, item):
        self.items.insert(0,item)

    def dequeue(self):
        return self.itmes.pop()

    def size(self):
        return len(self.itmes)
```



#### cons

模拟仿真，帮助得出解决问题的最优方案。
不消耗现实资源。


#### 热土豆问题

```py
from pythonds.basic.queue import Queue

def hotPotato(namelist, num):
    simqueue = Queue()
    for name in namelist:
        simqueue.enqueue(name)
    while simqueue.size() > 1:
        for i in range(num):
            simqueue.enqueue(simqueue.deque())
        simqueue.dequeue()
    return simqueue.dequeue()

hotPotato(["bi", "david", "susan", "jane", "jenny", "lisa", "bobby"],7)

0
['bobby', 'lisa', 'jenny', 'jane', 'susan', 'david', 'bi']
['bi', 'bobby', 'lisa', 'jenny', 'jane', 'susan', 'david']
1
['bi', 'bobby', 'lisa', 'jenny', 'jane', 'susan', 'david']
['david', 'bi', 'bobby', 'lisa', 'jenny', 'jane', 'susan']
2
['david', 'bi', 'bobby', 'lisa', 'jenny', 'jane', 'susan']
['susan', 'david', 'bi', 'bobby', 'lisa', 'jenny', 'jane']
0
['susan', 'david', 'bi', 'bobby', 'lisa', 'jenny']
['jenny', 'susan', 'david', 'bi', 'bobby', 'lisa']
1
['jenny', 'susan', 'david', 'bi', 'bobby', 'lisa']
['lisa', 'jenny', 'susan', 'david', 'bi', 'bobby']
2
['lisa', 'jenny', 'susan', 'david', 'bi', 'bobby']
['bobby', 'lisa', 'jenny', 'susan', 'david', 'bi']
0
['bobby', 'lisa', 'jenny', 'susan', 'david']
['david', 'bobby', 'lisa', 'jenny', 'susan']
1
['david', 'bobby', 'lisa', 'jenny', 'susan']
['susan', 'david', 'bobby', 'lisa', 'jenny']
2
['susan', 'david', 'bobby', 'lisa', 'jenny']
['jenny', 'susan', 'david', 'bobby', 'lisa']
0
['jenny', 'susan', 'david', 'bobby']
['bobby', 'jenny', 'susan', 'david']
1
['bobby', 'jenny', 'susan', 'david']
['david', 'bobby', 'jenny', 'susan']
2
['david', 'bobby', 'jenny', 'susan']
['susan', 'david', 'bobby', 'jenny']
0
['susan', 'david', 'bobby']
['bobby', 'susan', 'david']
1
['bobby', 'susan', 'david']
['david', 'bobby', 'susan']
2
['david', 'bobby', 'susan']
['susan', 'david', 'bobby']
0
['susan', 'david']
['david', 'susan']
1
['david', 'susan']
['susan', 'david']
2
['susan', 'david']
['david', 'susan']
```

#### printer

建模

![Screen Shot 2020-05-27 at 01.12.50](https://i.imgur.com/Zrsi3Xa.png)

![Screen Shot 2020-05-27 at 01.15.09](https://i.imgur.com/ZQxMv0n.png)

![Screen Shot 2020-05-27 at 01.15.33](https://i.imgur.com/RA8ygYd.png)

![Screen Shot 2020-05-27 at 01.17.19](https://i.imgur.com/jeTH4Qe.png)

![Screen Shot 2020-05-27 at 01.18.13](https://i.imgur.com/l1ZFgE3.png)

计算单位小时内打印机效率, average waiting time.

```py
from pythonds.basic.queue import Queue

import random

class Printer:
    def __init__(self, ppm):      # self define
        self.pagerate = ppm       # speed  pages/minute
        self.currentTask = None   # paint mission
        self.timeRemaining = 0    # current mission remain print time

    def tick(self):  # current status
        if self.currentTask != None:
            self.timeRemaining = self.timeRemaining -1
            if self.timeRemaining <=0:
                self.currentTask = None

    def busy(self):   # if busy?
        if self.currentTask != None:
            return True
        else:
            return False

    def startNext(self, newtask):
        self.currentTask = newtask
        self.timeRemaining = newtask.getpages() * 60 / self.pagerate  # (pages/speed)*60s


class Task:
    def __init__(self, time):
        self.timestamp = time                 # time created
        self.pages = random.randrange(1,21)   # pages

    def getStamp(self):
        return self.timestamp

    def getPages(self):
        return self.pages       

    def waitTime(self, currenttime):        # how long time it wait
         return currenttime - self.timestamp


def newPrintTask():    # whether if a new task creates
    num = random.randrange(1,181)    # 20task10student/hour -> 20task/hour -> 60*60/20 = 180/s
    if num == 181:
        return True
    else:
        return False


def simulation(numSeconds, pagesPerMinute):
    labprinter = Printer(pagesPerMinute)
    printQueue = Queue()
    waitingtimes = []

    for currentSecond in range(numSeconds):  # time period, add mission
        if newPrintTask():   
            task = Task(currentSecond)
            printQueue.enqueue(task)

    if (not labprinter.busy()) and (not printQueue.isEmpty()):
        nexttask = printQueue.dequeue()  # take the task out
        waitingtimes.append(nexttask.waitTime(currentSecond))
        labprinter.startNext(nexttask)
    labprinter.tick()  # keep working


    averageWait = sum(waitingtimes) / len(waitingtimes)

    print("Average wait %f secs %d tasks remaining." %(averageWait, printQueue.size()))

for i in range(10):
    simulation(3600,5)    # 5ppm, 1 hour, run 10 times
    simulation(3600,10)   # 10ppm, 1 hour, run 10 times
```

---

### 双端队列 deque

可以模拟stack或者queue

![Screen Shot 2020-05-27 at 16.08.22](https://i.imgur.com/1N3DXwM.png)

![Screen Shot 2020-05-27 at 16.08.36](https://i.imgur.com/bplESLY.png)


```py

class Deque:
    def __init__(self):
        self.itmes = []

    def isEmpty(self):
        return self.items == []

    def addFront(self, item):
        self.items.append(item)  # right

    def addRear(self, item):
        self.items.insert(item)  # left

    def removeFront(self):
        return self.items.pop()  # right

    def removeRear(self):
        return self.items.pop(0)  # right

    def size(self):
        return len(self.items)
```


### 回文词 判定

```py
from pythonds.basic.deque import Deque

def palchecker(aString):
    chardeque = Deque()

    for ch in aString:
        chardeque.addRear(ch)

    stillEqual = True

    while chardeque.size() > 1 and stillEqual:
        first = chardeque.removeFront()
        last = chardeque.removeRear()
        if first != last:
            stillEqual = False
    return stillEqual

palchecker("lsdkjfhd")
palchecker("radar")    
```

### 无序表抽象数据 unorderedlist Node

无序表： `unordered list`
- 一种数据按照相对位置存放的数据集
- (for easy, assum that no repeat)
- 无序存放，但是在数据相之间建立`链接指向`, 就可以保持其前后相对位置。
  - 显示标记 `head` `end`
- 每个节点 `node` 包含2信息：
  - 数据本身，指向下一个节点的引用信息`next`
  - `next=None` 没有下一个节点了

![Screen Shot 2020-05-27 at 16.20.16](https://i.imgur.com/phcl6Bx.png)

![Screen Shot 2020-05-27 at 16.20.28](https://i.imgur.com/qoU2e46.png)

```py
class Node:
    def __init__(self, initdata):
        self.data = initdata
        self.next = None

    def getData(self):
        return self.data

    def getNext(self):
        return self.next

    def setData(self, newdata):
        self.data = newdata

    def setNext(self, newnext):
        self.next = newnext        

temp = Node(93)
temp.getData
# 93
```

unorderedList:
- 无序表必须要有对第一个节点的引用信息
- 设立属性head，保存对第一个节点的引用空表的head为None

```py
class UnorderedList:
    def __init__(self):
        self.head = None

mylist = UnorderedList()
print mylist.head
# None
```

![Screen Shot 2020-05-27 at 16.50.31](https://i.imgur.com/Mlj8yQq.png)

![Screen Shot 2020-05-27 at 16.51.32](https://i.imgur.com/P5aBcmE.png)

![Screen Shot 2020-05-27 at 16.51.49](https://i.imgur.com/zHrnwxs.png)

![Screen Shot 2020-05-27 at 16.52.43](https://i.imgur.com/sojTC40.png)


链表实现

```py

def add(self, item):
    temp = Node(item)
    temp.setNext(self.head)
    self.head = temp

def size(self):
    current = self.head
    count = 0
    while current != None:
        count = count +1
        current = self.getNext()
    return count
# unordered List: O(n)
# ordered list: last one - first one / data size = data quantity: O(1)

def search(self, item):
    current = self.head
    found = False
    while current != None and not found:
        if current.getData() == item:
            found = True
        else:
            current = self.getNext()
    return found


def remove(self, item):
    previous = None
    current = self.head
    found = False    
    while not found:
        if current.getData() == item:
            found = True   # if found, stop loop.
        else:
            previous = current
            current = current.getNext()
    if previous == None:
        self.head = current.getNext()
    else:
        previous.setNext(current.getNext())
    return found
```


### 有序表抽象数据 ordereList

有序表，依照莫可比性质来决定列表位置
-


![Screen Shot 2020-05-27 at 17.13.05](https://i.imgur.com/PDoxAVV.png)

![Screen Shot 2020-05-27 at 17.14.07](https://i.imgur.com/DoL52o4.png)

```py
class UnorderedList:
    def __init__(self):
        self.head = None
```

![Screen Shot 2020-05-27 at 17.16.06](https://i.imgur.com/iNGDOg3.png)

```py

def add(self, item):    # 需要保持其有序性质
    current = self.head
    previous = None
    stop = False
    while current != None and not stop:
        if current.getData() > itme:
            stop = True
        else:
            previous = current
            current = current.getNext()
    temp = Node(item)
    if previous == None:
        temp.setNext(self.head)
        self.head = temp
    else:
        temp.setNext(current)
        previous.setNext(temp)



def search(self, item):
    current = self.head
    found = False
    stop = False
    while current != None and not found and not stop:
        if current.getData() == item:
            found = True
        else:
            if current.getData() > item:
                stop = True
            else:
                current = self.getNext()
    return found


def remove(self, item):
    previous = None
    current = self.head
    found = False    
    while not found:
        if current.getData() == item:
            found = True   # if found, stop loop.
        else:
            previous = current
            current = current.getNext()
    if previous == None:
        self.head = current.getNext()
    else:
        previous.setNext(current.getNext())
    return found
```

![Screen Shot 2020-05-27 at 17.30.56](https://i.imgur.com/9EmcAL9.png)

![Screen Shot 2020-05-27 at 17.31.35](https://i.imgur.com/C3Pu2j5.png)













.

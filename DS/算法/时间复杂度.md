
## 常见算法时间复杂度：

O(1): 表示算法的运行时间为常量

O(n): 表示该算法是线性算法

O(㏒2n): 二分查找算法

O(n2): 对数组进行排序的各种简单算法，例如直接插入排序的算法。

O(n3): 做两个n阶矩阵的乘法运算

O(2n): 求具有n个元素集合的所有子集的算法

O(n!): 求具有N个元素的全排列的算法

优<---------------------------<劣

`O(1)<O(㏒n)<O(n)<O(n ㏒n)<O(n^2)<O(2^n)<O(n!)`

常数阶O(1)、对数阶O(log2n)、线性阶O(n)、线性对数阶O(nlog2n)、平方阶O(n2)、立方阶O(n3)、……k次方阶O(nk)、指数阶O(2n)。

 
算法的执行次数是 `T(n)`，
- 随着n增加而增加速度最快的主导部分
- 只保留最高次项，同时忽略最高项的系数后得到函数 `f(n)`，
- 此时算法的时间复杂度就是 `O(f(n))`
- 1, log(n), n, n*log(n), n^2, n^3, 2^n

运行规模和运行时间


### O(n): 表示该算法是线性算法

```
sum=1;
解: O(1): 表示算法的运行时间为常量
T(n)=1


a=0;
b=1;               ① 1+1
for (i=1;i<=n;i++) ② n
{
    s=a+b;　　　　③ n-1
    b=a;　　　　　④ n-1
    a=s;　　　　　⑤ n-1
}
解: T(n)=2+n+3(n-1)=4n-1=O(n).


int aFunc(int n) {
    for(int i = 0; i<n; i++) {         // 0,1,...,n-1,n: 需要执行 (n + 1) 次
        printf("Hello, World!\n");     // 0,1,...,n-1:   需要执行 n 次
    }
    return 0;       // 需要执行 1 次
}
解: T(n)= (n + 1 + n + 1) = 2n + 2 =O(n).
```


### O(㏒N): 二分查找算法
```java
int i=1;                   // 1
while (i<=n) {
    i=i*2;                 // 设语句2的频度是f(n)
}
解： 2^f(n)<=n; f(n)<=log2(n)   
    取最大值f(n)= log2(n),
    T(n)=O(log2n)


void aFunc(int n) {
    for (int i = 2; i < n; i++) {  //2,3,....n:  n-1
        i *= 2;                    //假设循环次数为 t，则循环条件满足 2^t < n。
        printf("%i\n", i);
    }
}
2^t < n
t < log2(n)
```



### O(n ㏒N): 二分查找算法
```java
for(int i = 2; i < n; i++) {   // n
    int i=1;                   // 1
    while (i<=n) {
        i=i*2;                 // 设语句2的频度是f(n)
    }
}    
T(n)=O(nlog2(N))


void aFunc(int n) {
    for (int i = 2; i < n; i++) {  //2,3,....n:  n-1
        i *= 2;                    //假设循环次数为 t，则循环条件满足 2^t < n。
        printf("%i\n", i);
    }
}
2^t < n
t < log2(n)
```


### O(n^2): 对数组进行排序的各种简单算法，例如直接插入排序的算法。

```java
for (i=1;i<n;i++){
    for (j=0;j<=n;j++) {
        x++;   
    }
} 
时间复杂度T(n)=O(n^2)    
```


### O(n^3): 做两个n阶矩阵的乘法运算

n^3 的增长速度是远超 n^2 的，同时 n^2 的增长速度是远超 n 的。
T(n) = n^3 + n^2 + 29，此时时间复杂度为 O(n^3)。

```
for(i=0;i<n;i++){           // i=m
    for(j=0;j<i;j++){       // j=(m-1)*m
        for(k=0;k<j;k++)    // k=(m-1)m-1
            x=x+2;  
    }
}
假设: i=m, 
k=j <- 内层循环的次数为k 
当i=m时, j 可以取 0,1,...,m-1 , 

```



O(2n): 求具有n个元素集合的所有子集的算法

O(n!): 求具有N个元素的全排列的算法


---


# 空间复杂度


## O(1)

```
int y = 0;
y++
```


## O(n)
```java
int [] newArray = new int[n];
for(int i = 0; i < n; i++) {   // n
    newArray[i] = i;
}    
```




## O(n^2)





。